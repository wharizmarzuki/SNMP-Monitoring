Based on the logs and code provided, the issue is a **`DetachedInstanceError`** in your backend application.

This happens because the application tries to access a database object (`alert_record`) inside a background thread (the email callback) after the original database session that created it has been closed.

### The Error

In `backend.log` , we see this traceback:

```text
Exception in thread Thread-1 (_send_and_callback):
...
  File "/home/harez/Project/snmp-monitoring/backend/services/alert_service.py", line 41, in email_callback
    models.AlertHistory.id == alert_record.id
sqlalchemy.orm.exc.DetachedInstanceError: Instance <AlertHistory ...> is not bound to a Session; attribute refresh operation cannot proceed
```

### The Cause

1.  **Session Expiration:** When you create the `alert_record` in the main thread, the code eventually commits the transaction (likely in `create_alert_record`). In SQLAlchemy, committing a session "expires" all instances attached to it. This means their data is cleared from memory and must be re-fetched from the database the next time you access them.
2.  **Threading Race Condition:** You are sending emails in a background thread using `send_email_background`.
3.  **Session Closure:** The main thread (handling the HTTP request or polling loop) finishes its work and **closes the database session** while the background thread is still sending the email.
4.  **Access on Detached Object:** When the email finishes and `email_callback` runs, it tries to access `alert_record.id`. Since the object is expired, SQLAlchemy tries to refresh it. But because the original session is now closed, it cannot connect to the database to refresh the data, causing the `DetachedInstanceError`.

### The Solution

You need to extract the primitive `id` (integer) from the `alert_record` **before** defining the callback or starting the thread. Passing the simple integer ID is safe because it doesn't require an active database session link.

**File to fix:** `backend/services/alert_service.py`

**Current Code (Buggy):**

```python
    @staticmethod
    def _notify(subject: str, body: str, db: Session, alert_record: Optional[models.AlertHistory] = None):
        # ... (recipients fetching) ...

        def email_callback(success: bool, recipients: list[str], error: str | None):
            """Callback to update alert history with email status."""
            if alert_record:  # <--- Accessing the object here causes issues
                # ...
                # Re-query alert record in this session
                record = db_thread.query(models.AlertHistory).filter(
                    models.AlertHistory.id == alert_record.id  # <--- ERROR: Accessing .id on detached object
                ).first()
                # ...

        send_email_background(subject, body, recipient_list, callback=email_callback)
```

**Fixed Code:**
Capture the `alert_id` in a variable before the callback definition.

```python
    @staticmethod
    def _notify(subject: str, body: str, db: Session, alert_record: Optional[models.AlertHistory] = None):
        """
        Fetch recipients from database and send email notification.
        Updates alert_record with email status if provided.
        """
        recipients_db = db.query(models.AlertRecipient).all()
        recipient_list = [r.email for r in recipients_db]

        if not recipient_list:
            logger.warning(f"⚠️ Alert triggered but no recipients found in DB!")
            if alert_record:
                AlertHistoryService.update_email_status(db, alert_record, False, [], "No recipients configured")
                db.commit()
            return

        # FIX: Extract the ID here, while the session is still active
        alert_id = alert_record.id if alert_record else None

        def email_callback(success: bool, recipients: list[str], error: str | None):
            """Callback to update alert history with email status."""
            if alert_id: # Use the integer ID, not the object
                # Need new session for thread-safe database access
                from app.core.database import SessionLocal
                db_thread = SessionLocal()
                try:
                    # Re-query alert record in this session using the ID
                    record = db_thread.query(models.AlertHistory).filter(
                        models.AlertHistory.id == alert_id
                    ).first()
                    if record:
                        AlertHistoryService.update_email_status(db_thread, record, success, recipients, error)
                        db_thread.commit()
                finally:
                    db_thread.close()

        send_email_background(subject, body, recipient_list, callback=email_callback)
```